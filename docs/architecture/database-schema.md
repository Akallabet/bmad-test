# Database Schema

## SQLite Database Schema

```sql
-- tasks table (generated by Drizzle migrations)
CREATE TABLE tasks (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  text TEXT NOT NULL,
  created_at INTEGER NOT NULL,  -- Unix timestamp (milliseconds)
  archived_at INTEGER,           -- Unix timestamp (milliseconds), NULL = active
  sort_order INTEGER NOT NULL
);

-- Indexes for query performance
CREATE INDEX idx_tasks_archived_at ON tasks(archived_at);
CREATE INDEX idx_tasks_sort_order ON tasks(sort_order);
CREATE INDEX idx_tasks_created_at ON tasks(created_at);
```

## Drizzle Schema Definition

```typescript
// packages/api/src/db/schema.ts
import { sqliteTable, integer, text, index } from 'drizzle-orm/sqlite-core';

export const tasks = sqliteTable('tasks', {
  id: integer('id').primaryKey({ autoIncrement: true }),
  text: text('text').notNull(),
  createdAt: integer('created_at', { mode: 'timestamp' }).notNull(),
  archivedAt: integer('archived_at', { mode: 'timestamp' }),
  sortOrder: integer('sort_order').notNull(),
}, (table) => ({
  archivedAtIdx: index('idx_tasks_archived_at').on(table.archivedAt),
  sortOrderIdx: index('idx_tasks_sort_order').on(table.sortOrder),
  createdAtIdx: index('idx_tasks_created_at').on(table.createdAt),
}));

// Type inference from schema
export type DbTask = typeof tasks.$inferSelect;
export type DbInsertTask = typeof tasks.$inferInsert;
```

## Query Examples

```typescript
// packages/api/src/db/queries.ts
import { eq, isNull, isNotNull, asc, desc } from 'drizzle-orm';
import { db } from './client';
import { tasks } from './schema';

// Get all active tasks sorted by sortOrder
export async function getActiveTasks() {
  return await db
    .select()
    .from(tasks)
    .where(isNull(tasks.archivedAt))
    .orderBy(asc(tasks.sortOrder));
}

// Get all archived tasks
export async function getArchivedTasks() {
  return await db
    .select()
    .from(tasks)
    .where(isNotNull(tasks.archivedAt))
    .orderBy(desc(tasks.archivedAt)); // Most recently archived first
}

// Create new task with auto-generated sortOrder
export async function createTask(text: string) {
  // Get next sortOrder value
  const result = await db
    .select({ maxSort: tasks.sortOrder })
    .from(tasks)
    .orderBy(desc(tasks.sortOrder))
    .limit(1);

  const nextSortOrder = (result[0]?.maxSort ?? 0) + 1;

  const [newTask] = await db
    .insert(tasks)
    .values({
      text,
      createdAt: new Date(),
      archivedAt: null,
      sortOrder: nextSortOrder,
    })
    .returning();

  return newTask;
}

// Update task text
export async function updateTaskText(id: number, text: string) {
  const [updated] = await db
    .update(tasks)
    .set({ text })
    .where(eq(tasks.id, id))
    .returning();

  if (!updated) throw new Error('Task not found');
  return updated;
}

// Archive task (idempotent)
export async function archiveTask(id: number) {
  const [archived] = await db
    .update(tasks)
    .set({ archivedAt: new Date() })
    .where(eq(tasks.id, id))
    .returning();

  if (!archived) throw new Error('Task not found');
  return archived;
}

// Restore task (idempotent)
export async function restoreTask(id: number) {
  const [restored] = await db
    .update(tasks)
    .set({ archivedAt: null })
    .where(eq(tasks.id, id))
    .returning();

  if (!restored) throw new Error('Task not found');
  return restored;
}

// Batch reorder tasks
export async function reorderTasks(updates: Array<{ id: number; sortOrder: number }>) {
  await db.transaction(async (tx) => {
    for (const { id, sortOrder } of updates) {
      await tx
        .update(tasks)
        .set({ sortOrder })
        .where(eq(tasks.id, id));
    }
  });
}
```

## Database Initialization

```typescript
// packages/api/src/db/client.ts
import Database from 'better-sqlite3';
import { drizzle } from 'drizzle-orm/better-sqlite3';
import { migrate } from 'drizzle-orm/better-sqlite3/migrator';
import * as schema from './schema';

// Create in-memory SQLite database
const sqlite = new Database(':memory:');

// Enable foreign keys (though we don't use them in MVP)
sqlite.pragma('foreign_keys = ON');

// Create Drizzle instance
export const db = drizzle(sqlite, { schema });

// Run migrations on startup
export async function initializeDatabase() {
  try {
    await migrate(db, { migrationsFolder: './src/db/migrations' });
    console.log('Database migrations applied successfully');
  } catch (error) {
    console.error('Database migration failed:', error);
    throw error;
  }
}

// Health check - verify database is accessible
export function checkDatabaseHealth(): boolean {
  try {
    const result = sqlite.prepare('SELECT 1').get();
    return result !== undefined;
  } catch {
    return false;
  }
}
```

**Performance Characteristics:**

- **Typical Query Times (in-memory):**
  - SELECT all tasks: < 1ms
  - INSERT task: < 2ms (includes sortOrder calculation)
  - UPDATE task: < 1ms
  - Batch reorder (10 tasks): < 5ms (transaction overhead)

- **Scalability Limits (in-memory):**
  - < 1,000 tasks: Excellent performance
  - 1,000 - 10,000 tasks: Good performance, consider pagination
  - > 10,000 tasks: Migrate to persistent SQLite file or PostgreSQL

**Known Limitations:**

- ❌ No soft delete tracking (who archived the task)
- ❌ No audit log (history of changes)
- ❌ No full-text search index on `text` field
- ❌ No composite indexes (e.g., `archived_at + sort_order`)
- ❌ No database-level constraints on text length (relies on application validation)
